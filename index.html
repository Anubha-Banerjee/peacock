<html>
  <head>
    <script src="jquery-1.8.3.min.js"></script>
    <script src="three.min.js"></script>
    <script src="OrbitAndPanControls.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="Coordinates.js"></script>
    <script src="dat.gui.min.js"></script>
  </head>
  <body>
    <div id="container" style="height: 492px, width: 876px"></div>
    
   <script type="text/javascript">
    ////////////////////////////////////////////////////////////////////////////////
// Change from fixed steps to timed updates
////////////////////////////////////////////////////////////////////////////////
/*global THREE Coordinates, document, window, container, Stats;*/

var camera, scene, renderer, stats;
var cameraControls;

var clock = new THREE.Clock();

var cylinder, sphere, cube;

var bevelRadius = 1.9;	// TODO: 2.0 causes some geometry bug.

var headlight;

var mouseDown = 0;

var bird, pencil;

var tiltDirection = 1;

var line;
var mouseX = 0.0; mouseY = 0.0;
var prevMouseX = 0.0; prevMouseY = 0.0;
var points = [];

var epsilon = 2;
	
//var canvasWidth = 846;
//var canvasHeight = 494;

 var material = new THREE.LineBasicMaterial({
        color: 0x1F1F1F
    });
	


document.getElementsByTagName("body")[0].style.cursor = "url('none.png'), auto";



$(document).mousedown(function() {
   mouseDown = 1;
   points.length = 0;
});


$(document).mouseup(function() {
   mouseDown = 0;	
   startSmoothing();
   
});


$(document).on('mousemove',function(e){

      prevMouseX = mouseX;
	  prevMouseY = mouseY;

	  mouseX =  (e.clientX - canvasWidth/2.0) * 2.0;// - canvasWidth	
	  mouseY =  (e.clientY - canvasHeight/2.0) * 2.0;// - canvasHeight;


	if(mouseDown)
	{
		  createLine();	  
	}
	});

	
function init() {
	// For grading the window is fixed in size; here's general code:
	canvasWidth = window.innerWidth / 1.4;
	canvasHeight = window.innerHeight / 1.4;

	// RENDERER
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.gammaInput = true;
	renderer.gammaOutput = true;
	renderer.setSize(canvasWidth, canvasHeight);
	renderer.setClearColorHex( 0x0, 1.0 );
	renderer.shadowMapEnabled = true;

	// CAMERA
	camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 4000 );
	camera.position.set(0, 1400, 0 );
	//camera.position.set( 19,1678,1688);

	// CONTROLS
	cameraControls = new THREE.OrbitAndPanControls(camera, renderer.domElement);
	cameraControls.target.set(0,310,0);

	var delta = clock.getDelta();
	cameraControls.update(delta);

	


}

function fillScene() {
	scene = new THREE.Scene();
	scene.fog = new THREE.Fog( 0x0, 2000, 4000 );

	// LIGHTS
	scene.add( new THREE.AmbientLight( 0x222222 ) );

	headlight = new THREE.PointLight( 0xFFFFFF, 1.0 );
	scene.add( headlight );

	var light = new THREE.SpotLight( 0xFFFFFF, 1.0 );
	light.position.set( -600, 1200, 300 );
	light.angle = 20 * Math.PI / 180;
	light.exponent = 1;
	light.target.position.set( 0, 200, 0 );
	light.castShadow = true;

	scene.add( light );

	
	// pencil
	pencil = new THREE.Object3D();
	createpencil(pencil);
   
	scene.add( pencil );

		var texture = THREE.ImageUtils.loadTexture('page3.jpg', {}, function() {
         renderer.render(scene);
        });

		pageMaterial = new THREE.MeshLambertMaterial ({map: texture,  specular: 0x555555, shininess: 20});		
		

	 var solidGround = new THREE.Mesh(
	new THREE.PlaneGeometry( 2000, 2000),
	pageMaterial);
	 solidGround.rotation.x = - Math.PI / 2;
     solidGround.receiveShadow = true;
	 scene.add( solidGround );


}



function startSmoothing()
{	
alert("initial : " + points.length);
var rs = [];
	rs = properRDP(points,0.2);	
	alert("laaaaaaater : " + rs.length);
	
	var red  = new THREE.MeshPhongMaterial({ ambient: 0x964514, color: 0xFF0000	, specular: 0x555555, shininess: 20 });
  	for(var i = 0; i < points.length; i++)
	{
	   var geometry = new THREE.Geometry();
	   var startPoint = points[i];
	   var endPoint = points[i+1];

	   geometry.vertices.push(new THREE.Vector3(startPoint.x, 0, startPoint.y));
	   geometry.vertices.push(new THREE.Vector3(endPoint.x, 0, endPoint.y));	
	   
	   line = new THREE.Line(geometry, red);
	   scene.add(line); 	  
	}
	
}


function properRDP(points,epsilon){

	var firstPoint=points[0];
    var lastPoint=points[points.length-1];
    if (points.length<3){
        return points;
    }
    var index=-1;
    var dist=0;
    for (var i=1;i<points.length-1;i++){
        var cDist=findPerpendicularDistance(points[i],firstPoint,lastPoint);
        if (cDist>dist){
            dist=cDist;
            index=i;
        }
    }
    if (dist>epsilon){
        // iterate
        var l1=points.slice(0, index+1);
        var l2=points.slice(index);
        var r1=properRDP(l1,epsilon);
        var r2=properRDP(l2,epsilon);
        // concat r2 to r1 minus the end/startpoint that will be the same
        var rs=r1.slice(0,r1.length-1).concat(r2);
        return rs;
    }else{
        return [firstPoint,lastPoint];
    }
}

    
    
function findPerpendicularDistance(p, p1,p2) {
    // if start and end point are on the same x the distance is the difference in X.
    var result;
    var slope;
    var intercept;
    if (p1.x==p2.x){
        result=Math.abs(p[0]-p1[0]);
    }else{
        slope = (p2.y - p1.y) / (p2.x - p1.x);
        intercept = p1.y - (slope * p1.x);
		
        result = Math.abs(slope * p[0] - p[1] + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
		alert(result);
    }   
	
    return result;
}


function createLine()
{ 
/*
   var geometry = new THREE.Geometry();
   

   geometry.vertices.push(new THREE.Vector3(prevMouseX, 0, prevMouseY));
   geometry.vertices.push(new THREE.Vector3(mouseX, 0, mouseY));	
   
   line = new THREE.Line(geometry, material);
   scene.add(line);*/
   points.push({x:mouseX, y:mouseY});
}




      function createpencil(ppencil)
	  {	
	    var rubber_length= 10;
		var pencil_length = 330;
		var pencil_radius = 40;
		var tip_radius = 10;
		var neck_length = 60;
		var tip_length = 20;
	

		var pencilMaterial  = new THREE.MeshPhongMaterial({ ambient: 0x964514, color: 0xE3A869	, specular: 0x555555, shininess: 20 });
		var tipMaterial  = new THREE.MeshPhongMaterial({ ambient: 0x964514, color: 0x000000	, specular: 0x555555, shininess: 20 });

		//var texture = THREE.ImageUtils.loadTexture( 'halloween.jpg');

		 texture = THREE.ImageUtils.loadTexture('halloween.jpg', {}, function() {
         renderer.render(scene);
        });

		paintMaterial = new THREE.MeshPhongMaterial({map: texture, specular: 0xFFFFFF, shininess: 120 });		
		pencilMaterial.side = THREE.DoubleSide;
	    
		 // rubber
		var cylinder;
		cylinder = new THREE.Mesh(
		new THREE.CylinderGeometry( pencil_radius, pencil_radius, rubber_length, 32, 10, 0 ), tipMaterial );
		
		
		cylinder.position.x = mouseX;	
		cylinder.position.y = pencil_length + neck_length + tip_length + rubber_length/2;	
		cylinder.position.z = mouseY;	
		cylinder.castShadow = true;
		cylinder.receiveShadow = false;
		//scene.add( cylinder );
		ppencil.add(cylinder);


	    // body
		var cylinder;
		cylinder = new THREE.Mesh(
		new THREE.CylinderGeometry( pencil_radius, pencil_radius, pencil_length, 32, 10, 0 ), paintMaterial );
		
				

		cylinder.position.x = mouseX;	
		cylinder.position.y = pencil_length/2 + neck_length + tip_length;	
		cylinder.position.z = mouseY;	
		cylinder.castShadow = true;
		cylinder.receiveShadow = false;
		//scene.add( cylinder );
		ppencil.add(cylinder);
			
		
	    // neck
		var cylinder;
		cylinder = new THREE.Mesh(
		new THREE.CylinderGeometry( pencil_radius, tip_radius, neck_length, 32, 10, 0 ), pencilMaterial );
		
		
		cylinder.position.x = mouseX;	
		cylinder.position.y = neck_length/2 + tip_length;	
		cylinder.position.z = mouseY;	
		cylinder.castShadow = true;
		cylinder.receiveShadow = false;
		//scene.add( cylinder );
		ppencil.add(cylinder);
		
			
	    // tip
		var cylinder;
		cylinder = new THREE.Mesh(
		new THREE.CylinderGeometry( tip_radius, 0, tip_length, 32, 10, 1 ), tipMaterial );
		
		
		cylinder.position.x = mouseX;	
		cylinder.position.y = tip_length/2;	
		cylinder.position.z = mouseY;	
		cylinder.castShadow = true;
		cylinder.receiveShadow = false;
		//scene.add( cylinder );
		ppencil.add(cylinder);

		ppencil.rotation.y = 60;
		ppencil.rotation.x = 20;
		ppencil.rotation.z = 44.5;
		
	  }


function addToDOM() {

	var container = document.getElementById('container');
	var canvas = container.getElementsByTagName('canvas');
	if (canvas.length>0) {
		container.removeChild(canvas[0]);
	}
	container.appendChild( renderer.domElement );
}

function drawHelpers() {

}

function animate() {
	window.requestAnimationFrame(animate);
	render();
}

function render() {
	
	pencil.position.x = mouseX 	;
	pencil.position.z = mouseY ;	
	headlight.position.copy( camera.position );
	renderer.render(scene, camera);
}

try {
	init();
	fillScene();
	drawHelpers();
	addToDOM();
	animate();
} catch(e) {
	var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
	$('#container').append(errorReport+e);
}
    </script>
  </body>
</html>
